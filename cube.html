<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubeee</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js';
      const degreesToRads = deg => (deg * Math.PI) / 180.0;


        let renderer, scene, camera;
        let renderTarget;
        let cubeScene, screenScene, screenCamera;
        let cube;

        init();
        animate();

        function init() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            renderTarget = new THREE.WebGLRenderTarget(width, height, {
                format: THREE.RGBAFormat,
                type: THREE.UnsignedByteType,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                depthBuffer: true,
                stencilBuffer: false
            });

            cubeScene = new THREE.Scene();
            cubeScene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 10);
            camera.position.z = 3;

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshNormalMaterial();

            cube = new THREE.Mesh(geometry, material);
            cubeScene.add(cube);

            screenScene = new THREE.Scene();
            screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            const quadGeometry = new THREE.PlaneGeometry(2, 2);

            const screenMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    normalMap: { value: renderTarget.texture },
                    resolution: { value: new THREE.Vector2(width, height) }
                },
                vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    uniform sampler2D normalMap;
                    uniform vec2 resolution;

                    vec4 texture2DAA(sampler2D tex, vec2 uv) 
                    {
                        vec2 texsize = vec2(textureSize(tex,0));
                        vec2 uv_texspace = uv*texsize;
                        vec2 seam = floor(uv_texspace+.1);
                        uv_texspace = (uv_texspace-seam)/fwidth(uv_texspace)+seam;
                        uv_texspace = clamp(uv_texspace, seam-.5, seam+.5);
                        return texture(tex, uv_texspace/texsize);
                    }

                    vec3 GetNormal(vec2 uv, sampler2D normalTexture)
                    {
                        vec3 normal = texture(normalTexture, uv).rgb;
                        //ec3 normal = texture2DAA(normalTexture, uv).rgb;
                        normal = normal * 2.0 - 1.0;
                        return normal;
                    }

           
    

                    float normal_edges_bias(vec3 edge_bias, vec3 normal, vec3 nNormal)
                    {
                        float normal_diff = dot(normal - nNormal, edge_bias);
                        float normalIndicator = clamp(smoothstep(-.01, .01, normal_diff), 0.0, 1.0);
                        return distance(normal, nNormal) *  normalIndicator;
                    }
            

                    void main() {

                        vec2 texelSize = vec2(1.0) / resolution;

                        vec2 uv = gl_FragCoord.xy / resolution;
                        // Flip Y coordinate to match Three.js texture coordinates
                        uv.y = 1.0 - uv.y;

                        //vec3 normal = texture2D(normalMap, uv).rgb;
                        //normal = normalize(normal * 2.0 - 1.0);
                        vec3 normal = GetNormal(uv, normalMap);

                        
                        vec3 normal_left = GetNormal(uv + vec2(-1.0, 0.0) * texelSize, normalMap).rgb;
                        vec3 normal_right = GetNormal(uv + vec2(1.0, 0.0) * texelSize, normalMap).rgb;
                        vec3 normal_top = GetNormal(uv + vec2(0.0, -1.0) * texelSize, normalMap).rgb;
                        vec3 normal_bottom = GetNormal(uv + vec2(0.0, +1.0) * texelSize, normalMap).rgb;


                        float normal_diff = 0.0;
                        vec3 bias = vec3(1.0, 1.0, 1.0);
                        normal_diff += normal_edges_bias(bias, normal, normal_left);
                        normal_diff += normal_edges_bias(bias, normal, normal_right);
                        normal_diff += normal_edges_bias(bias, normal, normal_top);
                        normal_diff += normal_edges_bias(bias, normal, normal_bottom);

                        
                        gl_FragColor = vec4(vec3(normal_diff), 1.0);

                   
                    }
                `
            });

            const quad = new THREE.Mesh(quadGeometry, screenMaterial);
            screenScene.add(quad);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            renderTarget.setSize(width, height);

            screenScene.children[0].material.uniforms.resolution.value.set(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);

            cube.rotation.x += 0.01;
            cube.rotation.y = 0.0;
            cube.rotation.z += 0.01;

            renderer.setRenderTarget(renderTarget);
            renderer.render(cubeScene, camera);

            renderer.setRenderTarget(null);
            renderer.render(screenScene, screenCamera);
        }
    </script>
</body>

</html>
